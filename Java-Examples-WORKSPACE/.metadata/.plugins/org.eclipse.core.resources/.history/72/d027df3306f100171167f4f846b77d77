Java 8 in Action

- Java 8 provides a new API (called Streams) that supports many parallel operations to process
	data and resembles the way you might think in database query languages—you express what you
	want in a higher-level manner, and the implementation (here the Streams library) chooses the
	best low-level execution mechanism. As a result, it avoids the need for you to write code that
	uses synchronized, which is not only highly error prone but is also more expensive than you may
	realize on multicore CPUs.
- A stream is a sequence of data items that are conceptually produced one at a time
- Stream<T> (interface) is a sequence of items of type T.
- In the imperative programming paradigm you typically describe a program in terms of a sequence of statements that mutate state
- What describes functional programming?
	- Two of these points 
		1. No shared mutable data and 
		2. The ability to pass methods and functions—code—to other methods
	 are the cornerstones of what’s generally described as the paradigm of functional programming,	

- Lambdas (Anonymous functions)
	- Java 8 allows a richer idea of functions as values, including lambdas (or anonymous functions).
	- For example, you can now write (int x) -> x + 1 to mean 
	  “the function that, when called with argument x, returns the value x + 1.”
	- A lambda expression can be understood as a concise representation of an anonymous function
		that can be passed around: it doesn’t have a name, but it has a list of parameters, a body, a
		return type, and also possibly a list of exceptions that can be thrown.

- Functional Programming
	- The primary meaning of functional in functional programming means “using functions as first class values,” 
	  it often has a secondary nuance of “no interaction during execution between components."

- Behavior Parameterization
	- Behavior parameterization means: the ability to tell a method to take multiple behaviors
	(or strategies) as parameters and use them internally to accomplish different behaviors.
- Functional interface
	- A functional interface is an interface that specifies exactly one abstract method.
	- E.g., 1: java.util.Comaparator
			2: java.lang.Runnable
			3: java.awt.event.ActionListener
			4: java.util.concurrent.Callable
			5: java.security.PrivilegedAction
	- An interface is still a functional interface if it has many default methods as long as it
	specifies only one abstract method.
	- Lambda expressions let you provide the implementation of the abstract method of a functional interface directly inline 
	and treat the whole expression as an instance of a functional interface
	- @FunctionalInterface
		- This annotation is used to indicate that the interface is intended to be a functional interface. 
		- The compiler will return a meaningful error if you define an interface using the 
		  @FunctionalInterface annotation and it isn’t a functional interface.
		- Note that the @FunctionalInterface annotation isn’t mandatory, but it’s good practice to use it when an 
		  interface is designed for that purpose.
		- Functional interfaces are useful because the signature of the abstract method can describe the signature of a lambda expression. 
		  The signature of the abstract method of a functional interface is called a function descriptor.
		- Java 8's in built functional interfaces,
			- java.util.function.Predicate<T>
			- java.util.function.Consumer<T>
			- java.util.function.Function<T, R>
	- Closure
		- a closure is an instance of a function that can reference nonlocal variables of that function with no restrictions. 
		  For example, a closure could be passed as argument to another function. It could also access and modify variables 
		  defined outside its scope.
	- Streams
		- A sequence of elements from a source that supports data processing operations.
		- Collections are about data; streams are about computations
		- Streams support database-like operations and common operations from functional programming languages to manipulate data, 
		  such as filter, map, reduce, find,match, sort, and so on. 
		- Stream operations can be executed either sequentially or in parallel.
		- Streams are an update to the Java API that lets you manipulate collections of data in a
		  declarative way (you express a query rather than code an ad hoc implementation for it). 
		  For now you can think of them as fancy iterators over a collection of data.
		- Streams can be processed in parallel transparently, without you having to write any multithreaded code.
		- The Streams API in Java 8 lets you write code that’s
			1. Declarative — More concise and readable
			2. Composable — Greater flexibility
			3. Parallelizable — Better performance
		- Stream operations have two important characteristics
			1. Pipelining— Many stream operations return a stream themselves, allowing operations to be chained and form a larger pipeline
			2. Internal iteration— In contrast to collections, which are iterated explicitly using an iterator, stream operations do the iteration behind the scenes
		- A collection is an in-memory data structure that holds all the values
		- Similarly to iterators, a stream can be traversed only once.